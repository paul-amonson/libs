<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VoltWrapperClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libs</a> &gt; <a href="index.source.html" class="el_package">com.amonson.data_access</a> &gt; <span class="el_source">VoltWrapperClient.java</span></div><h1>VoltWrapperClient.java</h1><pre class="source lang-java linenums">// Copyright (C) 2021 Paul Amonson
//
// SPDX-License-Identifier: Apache-2.0
//
package com.amonson.data_access;

import org.apache.logging.log4j.core.Logger;
import org.voltdb.client.*;
import org.apache.commons.io.IOUtils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.Instant;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Class to wrap a VoltDB Client class. It controls connections to multiple servers configured as a cluster.
 * Properties Possible:
 *      list_of_servers - (Required; def = &quot;&quot;) Required comma separated list of VoltDB servers.
 *      username        - (Optional; def = &quot;&quot;) Username or empty string for credentials.
 *      password        - (Optional; def = &quot;&quot;) Password or empty string for credentials.
 *      port            - (Optional; def = &quot;21212&quot;) Port for VoltDB servers.
 *      retry_delay     - (Optional; def = &quot;2000&quot;) Delay between retries to a connection in milliseconds.
 *      resource_file   - (Optional) Resource file to load into VoltDB.
 *      filename        - (Optional) Filename in file system to load into VoltDB.
 *      jar_files       - (Optional) Comma separated list of JAR files to load into VoltDB (Must be Java 8 JARs)
 */
<span class="pc bpc" id="L31" title="1 of 2 branches missed.">class VoltWrapperClient extends ClientStatusListenerExt {</span>
    /**
     * Constructs the object and internal client but does not connect.
     *
     * @param properties Properties to configure the internal client.
     * @param logger This is where logging messages go.
     */
<span class="fc" id="L38">    VoltWrapperClient(Properties properties, Logger logger) {</span>
<span class="pc bpc" id="L39" title="2 of 6 branches missed.">        assert properties != null &amp;&amp; properties.containsKey(SERVERS);</span>
<span class="pc bpc" id="L40" title="2 of 4 branches missed.">        assert logger != null;</span>
<span class="fc" id="L41">        log_ = logger;</span>
<span class="fc" id="L42">        port_ = Integer.parseInt(properties.getProperty(PORT, Integer.toString(Client.VOLTDB_SERVER_PORT)));</span>
<span class="fc bfc" id="L43" title="All 2 branches covered.">        for(String server: properties.getProperty(SERVERS).split(&quot;,&quot;))</span>
<span class="fc" id="L44">            connections_.put(server, false);</span>
<span class="fc" id="L45">        properties_ = properties;</span>
<span class="fc" id="L46">        client_ = ClientFactory.createClient(initClient());</span>
<span class="fc" id="L47">    }</span>

    /**
     * Starts a connection thread that will attempt keep connections to the hosts.
     */
    public void connect() {
<span class="fc bfc" id="L53" title="All 2 branches covered.">        if(connectionThread_ != null)</span>
<span class="fc" id="L54">            return;</span>
<span class="fc" id="L55">        connectionThread_ = new Thread(() -&gt; {</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">            while(!Thread.currentThread().isInterrupted()) {</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">                for (Map.Entry&lt;String, Boolean&gt; entry : connections_.entrySet())</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">                    if (!entry.getValue())</span>
<span class="fc" id="L59">                        entry.setValue(connectInternal(entry.getKey()));</span>
                try {
<span class="pc" id="L61">                    Thread.sleep(Long.parseLong(properties_.getProperty(CONNECTION_RETRY_DELAY_MS,</span>
<span class="fc" id="L62">                            Long.toString(2_000L))));</span>
<span class="fc" id="L63">                } catch (InterruptedException e) {</span>
<span class="fc" id="L64">                    Thread.currentThread().interrupt();</span>
<span class="pc" id="L65">                }</span>
            }
<span class="fc" id="L67">        });</span>
<span class="fc" id="L68">        connectionThread_.start();</span>
<span class="fc" id="L69">    }</span>

    /**
     * Stops the connection thread that was attempting to keep connections to the hosts. Object cannot be reused
     * after disconnect is called on a connected client.
     */
    public void disconnect() {
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if(connectionThread_ == null)</span>
<span class="fc" id="L77">            return;</span>
<span class="fc" id="L78">        connectionThread_.interrupt();</span>
        try {
<span class="fc" id="L80">            connectionThread_.join();</span>
<span class="pc" id="L81">        } catch(InterruptedException e) { /* Ignore because we are closing anyway. */ }</span>
<span class="fc" id="L82">        connectionThread_ = null;</span>
        try {
<span class="fc" id="L84">            client_.drain();</span>
<span class="pc" id="L85">        } catch(NoConnectionsException | InterruptedException e) { /* No connection then drain() is not necessary */ }</span>
        try {
<span class="fc" id="L87">            client_.close();</span>
<span class="pc" id="L88">        } catch(InterruptedException e) { /* No connection then drain() is not necessary */ }</span>
<span class="fc" id="L89">    }</span>

    /**
     * &lt;p&gt;Synchronously invoke a procedure. Blocks until a result is available. A {@link ProcCallException}
     * is thrown if the response is anything other then success.&lt;/p&gt;
     *
     * @param procedureName &lt;code&gt;class&lt;/code&gt; name (not qualified by package) of the procedure to execute.
     * @param params vararg list of procedure's parameter values.
     * @return {@link ClientResponse} instance of procedure call results.
     * @throws ProcCallException on any VoltDB specific failure.
     * @throws NoConnectionsException if this {@link Client} instance is not connected to any servers.
     * @throws IOException if there is a Java network or connection problem.
     */
    public ClientResponse callProcedureSync(String procedureName, Object... params)
            throws IOException, ProcCallException {
<span class="fc" id="L104">        return client_.callProcedure(procedureName, params);</span>
    }

    /**
     * &lt;p&gt;Asynchronously invoke a replicated procedure, by providing a callback that will be invoked by the single
     * thread backing the client instance when the procedure invocation receives a response.
     * See the {@link Client} class documentation for information on the negative performance impact of slow or
     * blocking callbacks. If there is backpressure
     * this call will block until the invocation is queued. If configureBlocking(false) is invoked
     * then it will return immediately. Check the return value to determine if queueing actually took place.&lt;/p&gt;
     *
     * @param callback {@link ProcedureCallback} that will be invoked with procedure results.
     * @param procedureName class name (not qualified by package) of the procedure to execute.
     * @param params vararg list of procedure's parameter values.
     * @throws NoConnectionsException if this {@link Client} instance is not connected to any servers.
     * @throws IOException if there is a Java network or connection problem.
     */
    public void callProcedureAsync(ProcedureCallback callback, String procedureName, Object... params)
            throws IOException {
<span class="fc" id="L123">        client_.callProcedure(callback, procedureName, params);</span>
<span class="fc" id="L124">    }</span>

    /**
     * Checks for any connection to the VoltDB cluster.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if there is at least one connection; &lt;code&gt;false&lt;/code&gt; if there are no connections.
     */
    public boolean haveConnection() {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        return client_.getConnectedHostList().size() &gt; 0;</span>
    }

    /**
     * Waits for any connection to the VoltDB cluster with a timeout.
     * @param timeoutMilliseconds How many milliseconds to wait for a connection.
     * @return &lt;code&gt;true&lt;/code&gt; if a connection was made within the timeout period or already existed,
     * &lt;code&gt;false&lt;/code&gt; if no connection during timeout period.
     */
    public boolean waitForConnection(long timeoutMilliseconds) {
<span class="fc" id="L142">        long now = Instant.now().toEpochMilli();</span>
<span class="fc" id="L143">        long futureTimeout = now + timeoutMilliseconds;</span>
<span class="fc bfc" id="L144" title="All 4 branches covered.">        while(!haveConnection() &amp;&amp; now &lt; futureTimeout) { // Wait for at least one connection</span>
            try {
<span class="fc" id="L146">                Thread.sleep(100); // Busy wait intentional.</span>
<span class="pc" id="L147">            } catch(InterruptedException e) { /* Ignore this, should not happen */ }</span>
<span class="fc" id="L148">            now = Instant.now().toEpochMilli();</span>
        }
<span class="fc bfc" id="L150" title="All 2 branches covered.">        return now &lt; futureTimeout;</span>
    }

    /**
     * Using the configuration properties &quot;resource_file&quot;, &quot;filename&quot;, and &quot;jar_files&quot;. initialize the schema and
     * stored Java procedures (JARs). Resource files are attempted before file in the filesystem. Loading JARs is
     * last.
     *
     * @return true if everything present is loaded ok, false something was attempted to load and failed.
     */
    public boolean initializeVoltDBAfterConnect() {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if(!checkSchema()) {</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">            if (properties_.containsKey(RESOURCE_FILE)) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">                if (!loadSQLFromResource(properties_.getProperty(RESOURCE_FILE)))</span>
<span class="fc" id="L164">                    return false;</span>
            }
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (properties_.containsKey(FILENAME)) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                if (!loadSQLFromFile(properties_.getProperty(FILENAME)))</span>
<span class="fc" id="L168">                    return false;</span>
            }
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (properties_.containsKey(JAR_FILES)) {</span>
<span class="fc" id="L171">                return loadJarFiles(properties_.getProperty(JAR_FILES));</span>
            }
        }
<span class="fc" id="L174">        return true;</span>
    }

    @Override
    public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {
<span class="fc" id="L179">        connections_.put(hostname, false);</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">        if(connectionsLeft == 0)</span>
<span class="fc" id="L181">            log_.fatal(&quot;All connections to the VoltDB servers have been lost.&quot;);</span>
        else
<span class="fc" id="L183">            log_.warn(String.format(&quot;Connection to '%s' was disconnected for reason '%s', there are %d &quot; +</span>
<span class="fc" id="L184">                            &quot;connections left.&quot;, hostname, cause.toString(), connectionsLeft));</span>
<span class="fc" id="L185">    }</span>

    @Override
    public void connectionCreated(String hostname, int port, AutoConnectionStatus status) {
<span class="pc bpc" id="L189" title="1 of 4 branches missed.">        if(status == AutoConnectionStatus.SUCCESS &amp;&amp; !connections_.containsKey(hostname))</span>
<span class="fc" id="L190">            connections_.put(hostname, true);</span>
        else
<span class="fc" id="L192">            connections_.put(hostname, false);</span>
<span class="fc" id="L193">    }</span>

    private boolean checkSchema() {
        try {
<span class="fc" id="L197">            ClientResponse response = client_.callProcedure(&quot;@SystemCatalog&quot;, &quot;tables&quot;);</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if(response.getStatus() != ClientResponse.SUCCESS) {</span>
<span class="nc" id="L199">                log_.warn(&quot;Call to '@SystemCatalog' built-in procedure failed with: &quot; +</span>
<span class="nc" id="L200">                        response.getStatusString());</span>
<span class="nc" id="L201">                return false;</span>
            }
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">            return response.getResults()[0].getRowCount() &gt; 0;</span>
<span class="nc" id="L204">        } catch (NoConnectionsException e) {</span>
<span class="nc" id="L205">            log_.warn(&quot;No connection to VoltDB databases!&quot;);</span>
<span class="nc" id="L206">            log_.catching(e);</span>
<span class="nc" id="L207">            return false;</span>
<span class="nc" id="L208">        } catch (IOException e) {</span>
<span class="nc" id="L209">            log_.warn(&quot;I/O exception when calling to VoltDB databases!&quot;);</span>
<span class="nc" id="L210">            log_.catching(e);</span>
<span class="nc" id="L211">            return false;</span>
<span class="nc" id="L212">        } catch (ProcCallException e) {</span>
<span class="nc" id="L213">            log_.warn(&quot;Call to built in '@SystemCatalog' failed! Is the name correct?&quot;);</span>
<span class="nc" id="L214">            log_.catching(e);</span>
<span class="nc" id="L215">            return false;</span>
        }
    }

    private boolean loadJarFiles(String jarFiles) {
<span class="fc" id="L220">        String[] jars = jarFiles.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for(String jarFilename: jars) {</span>
<span class="fc" id="L222">            File jar = new File(jarFilename);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if(!jar.canRead()) {</span>
<span class="fc" id="L224">                log_.fatal(String.format(&quot;Jar file '%s' is missing or cannot be read!&quot;, jar));</span>
<span class="fc" id="L225">                return false;</span>
            }
            try {
<span class="fc" id="L228">                ClientResponse response = client_.updateClasses(jar, &quot;&quot;);</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">                if(response.getStatus() != ClientResponse.SUCCESS) {</span>
<span class="nc" id="L230">                    log_.fatal(String.format(&quot;Failed to call VoltDB: %s&quot;, response.getStatusString()));</span>
<span class="nc" id="L231">                    return false;</span>
                }
<span class="nc" id="L233">            } catch (IOException | ProcCallException e) {</span>
<span class="nc" id="L234">                log_.fatal(String.format(&quot;Failed to load the JAR file '%s' into VoltDB!&quot;, jar));</span>
<span class="nc" id="L235">                log_.catching(e);</span>
<span class="nc" id="L236">                return false;</span>
<span class="fc" id="L237">            }</span>
        }
<span class="fc" id="L239">        return true;</span>
    }

    private boolean loadSQLFromFile(String filename) {
<span class="fc" id="L243">        File file = new File(filename);</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if(!file.canRead()) {</span>
<span class="fc" id="L245">            log_.fatal(String.format(&quot;File '%s' does not exist or is not readable!&quot;, file));</span>
<span class="fc" id="L246">            return false;</span>
        }
        String sql;
        try {
<span class="fc" id="L250">            sql = new String(Files.readAllBytes(file.toPath()));</span>
<span class="nc" id="L251">        } catch (IOException e) {</span>
<span class="nc" id="L252">            log_.fatal(String.format(&quot;Failed to read SQL file '%s'&quot;, file));</span>
<span class="nc" id="L253">            log_.catching(e);</span>
<span class="nc" id="L254">            return false;</span>
<span class="fc" id="L255">        }</span>
        try {
<span class="fc" id="L257">            ClientResponse response = callProcedureSync(&quot;@AdHoc&quot;, sql);</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">            if(response.getStatus() != ClientResponse.SUCCESS) {</span>
<span class="nc" id="L259">                log_.fatal(String.format(&quot;Failed to call VoltDB: %s&quot;, response.getStatusString()));</span>
<span class="nc" id="L260">                return false;</span>
            }
<span class="nc" id="L262">        } catch(IOException | ProcCallException e) {</span>
<span class="nc" id="L263">            log_.fatal(String.format(&quot;Failed to load the SQL file '%s' into VoltDB!&quot;, file));</span>
<span class="nc" id="L264">            log_.catching(e);</span>
<span class="nc" id="L265">            return false;</span>
<span class="fc" id="L266">        }</span>
<span class="fc" id="L267">        return true;</span>
    }

    private boolean loadSQLFromResource(String resourceName) {
<span class="fc" id="L271">        InputStream stream = ClassLoader.getSystemResourceAsStream(resourceName);</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if(stream == null) {</span>
<span class="fc" id="L273">            log_.fatal(String.format(&quot;ClassLoader failed to get resource stream for '%s'!&quot;, resourceName));</span>
<span class="fc" id="L274">            return false;</span>
        }

        String sql;
        try {
<span class="fc" id="L279">            sql = IOUtils.toString(stream, StandardCharsets.UTF_8);</span>
<span class="nc" id="L280">        } catch (IOException e) {</span>
<span class="nc" id="L281">            log_.fatal(String.format(&quot;ClassLoader failed to get read the stream for '%s'!&quot;, resourceName));</span>
<span class="nc" id="L282">            log_.catching(e);</span>
<span class="nc" id="L283">            return false;</span>
<span class="fc" id="L284">        }</span>
        try {
<span class="fc" id="L286">            ClientResponse response = callProcedureSync(&quot;@AdHoc&quot;, sql);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">            if(response.getStatus() != ClientResponse.SUCCESS) {</span>
<span class="nc" id="L288">                log_.fatal(String.format(&quot;Failed to call VoltDB: %s&quot;, response.getStatusString()));</span>
<span class="nc" id="L289">                return false;</span>
            }
<span class="nc" id="L291">        } catch(IOException | ProcCallException e) {</span>
<span class="nc" id="L292">            log_.fatal(String.format(&quot;Failed to load the resource SQL '%s' into VoltDB!&quot;, resourceName));</span>
<span class="nc" id="L293">            log_.catching(e);</span>
<span class="nc" id="L294">            return false;</span>
<span class="fc" id="L295">        }</span>
<span class="fc" id="L296">        return true;</span>
    }

    private boolean connectInternal(String server) {
        try {
<span class="fc" id="L301">            client_.createConnection(server, port_);</span>
<span class="fc" id="L302">            return true;</span>
<span class="fc" id="L303">        } catch (IOException e) {</span>
<span class="fc" id="L304">            return false;</span>
        }
    }

    private ClientConfig initClient() {
        ClientConfig config;
<span class="fc" id="L310">        config = new ClientConfig(properties_.getProperty(USERNAME, &quot;&quot;), properties_.getProperty(PASSWORD, &quot;&quot;), this);</span>
<span class="fc" id="L311">        config.enableAutoTune();</span>
<span class="fc" id="L312">        config.setReconnectOnConnectionLoss(true);</span>
<span class="fc" id="L313">        config.setClientAffinity(true);</span>
<span class="fc" id="L314">        config.setTopologyChangeAware(true);</span>
<span class="fc" id="L315">        return config;</span>
    }

    private final Logger              log_;
    private final Properties          properties_;
<span class="fc" id="L320">    private final Map&lt;String,Boolean&gt; connections_ = new ConcurrentHashMap&lt;&gt;();</span>
    private       Client              client_;
    private final int                 port_;
<span class="fc" id="L323">    private       Thread              connectionThread_ = null;</span>

    public static final String USERNAME                  = &quot;username&quot;;
    public static final String PASSWORD                  = &quot;password&quot;;
    public static final String PORT                      = &quot;port&quot;;
    public static final String CONNECTION_RETRY_DELAY_MS = &quot;retry_delay&quot;;
    public static final String SERVERS                   = &quot;list_of_servers&quot;;
    public static final String RESOURCE_FILE             = &quot;resource_file&quot;;
    public static final String FILENAME                  = &quot;filename&quot;;
    public static final String JAR_FILES                 = &quot;jar_files&quot;;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>