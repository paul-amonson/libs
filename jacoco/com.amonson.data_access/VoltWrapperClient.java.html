<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VoltWrapperClient.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">libs</a> &gt; <a href="index.source.html" class="el_package">com.amonson.data_access</a> &gt; <span class="el_source">VoltWrapperClient.java</span></div><h1>VoltWrapperClient.java</h1><pre class="source lang-java linenums">// Copyright (C) 2021 Paul Amonson
//
// SPDX-License-Identifier: Apache-2.0
//
package com.amonson.data_access;

import org.voltdb.client.*;

import java.io.IOException;
import java.time.Instant;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Logger;

/**
 * Class to wrap a VoltDB Client class. It controls connections to multiple servers configured as a cluster.
 * Properties Possible:
 *      list_of_servers - (Required; def = &quot;&quot;) Required comma separated list of VoltDB servers.
 *      username        - (Optional; def = &quot;&quot;) Username or empty string for credentials.
 *      password        - (Optional; def = &quot;&quot;) Password or empty string for credentials.
 *      port            - (Optional; def = &quot;21212&quot;) Port for VoltDB servers.
 *      retry_delay     - (Optional; def = &quot;2000&quot;) Delay between retries to a connection in milliseconds.
 */
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">class VoltWrapperClient extends ClientStatusListenerExt {</span>
    /**
     * Constructs the object and internal client but does not connect.
     *
     * @param properties Properties to configure the internal client.
     * @param logger This is where logging messages go.
     */
<span class="fc" id="L32">    VoltWrapperClient(Properties properties, Logger logger) {</span>
<span class="pc bpc" id="L33" title="2 of 6 branches missed.">        assert properties != null &amp;&amp; properties.containsKey(SERVERS);</span>
<span class="pc bpc" id="L34" title="2 of 4 branches missed.">        assert logger != null;</span>
<span class="fc" id="L35">        log_ = logger;</span>
<span class="fc" id="L36">        port_ = Integer.parseInt(properties.getProperty(PORT, Integer.toString(Client.VOLTDB_SERVER_PORT)));</span>
<span class="fc bfc" id="L37" title="All 2 branches covered.">        for(String server: properties.getProperty(SERVERS).split(&quot;,&quot;))</span>
<span class="fc" id="L38">            connections_.put(server, false);</span>
<span class="fc" id="L39">        properties_ = properties;</span>
<span class="fc" id="L40">        client_ = ClientFactory.createClient(initClient());</span>
<span class="fc" id="L41">    }</span>

    /**
     * Starts a connection thread that will attempt keep connections to the hosts.
     */
    public void connect() {
<span class="fc bfc" id="L47" title="All 2 branches covered.">        if(connectionThread_ != null)</span>
<span class="fc" id="L48">            return;</span>
<span class="fc" id="L49">        connectionThread_ = new Thread(() -&gt; {</span>
<span class="fc bfc" id="L50" title="All 2 branches covered.">            while(!Thread.currentThread().isInterrupted()) {</span>
<span class="fc bfc" id="L51" title="All 2 branches covered.">                for (Map.Entry&lt;String, Boolean&gt; entry : connections_.entrySet())</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">                    if (!entry.getValue())</span>
<span class="fc" id="L53">                        entry.setValue(connectInternal(entry.getKey()));</span>
                try {
<span class="pc" id="L55">                    Thread.sleep(Long.parseLong(properties_.getProperty(CONNECTION_RETRY_DELAY_MS,</span>
<span class="fc" id="L56">                            Long.toString(2_000L))));</span>
<span class="fc" id="L57">                } catch (InterruptedException e) {</span>
<span class="fc" id="L58">                    Thread.currentThread().interrupt();</span>
<span class="pc" id="L59">                }</span>
            }
<span class="fc" id="L61">        });</span>
<span class="fc" id="L62">        connectionThread_.start();</span>
<span class="fc" id="L63">    }</span>

    /**
     * Stops the connection thread that was attempting to keep connections to the hosts. Object cannot be reused
     * after disconnect is called on a connected client.
     */
    public void disconnect() {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if(connectionThread_ == null)</span>
<span class="fc" id="L71">            return;</span>
<span class="fc" id="L72">        connectionThread_.interrupt();</span>
        try {
<span class="fc" id="L74">            connectionThread_.join();</span>
<span class="pc" id="L75">        } catch(InterruptedException e) { /* Ignore because we are closing anyway. */ }</span>
<span class="fc" id="L76">        connectionThread_ = null;</span>
        try {
<span class="fc" id="L78">            client_.drain();</span>
<span class="pc" id="L79">        } catch(NoConnectionsException | InterruptedException e) { /* No connection then drain() is not necessary */ }</span>
        try {
<span class="fc" id="L81">            client_.close();</span>
<span class="pc" id="L82">        } catch(InterruptedException e) { /* No connection then drain() is not necessary */ }</span>
<span class="fc" id="L83">    }</span>

    /**
     * &lt;p&gt;Synchronously invoke a procedure. Blocks until a result is available. A {@link ProcCallException}
     * is thrown if the response is anything other then success.&lt;/p&gt;
     *
     * @param procedureName &lt;code&gt;class&lt;/code&gt; name (not qualified by package) of the procedure to execute.
     * @param params vararg list of procedure's parameter values.
     * @return {@link ClientResponse} instance of procedure call results.
     * @throws ProcCallException on any VoltDB specific failure.
     * @throws NoConnectionsException if this {@link Client} instance is not connected to any servers.
     * @throws IOException if there is a Java network or connection problem.
     */
    public ClientResponse callProcedureSync(String procedureName, Object... params)
            throws IOException, ProcCallException {
<span class="fc" id="L98">        return client_.callProcedure(procedureName, params);</span>
    }

    /**
     * &lt;p&gt;Asynchronously invoke a replicated procedure, by providing a callback that will be invoked by the single
     * thread backing the client instance when the procedure invocation receives a response.
     * See the {@link Client} class documentation for information on the negative performance impact of slow or
     * blocking callbacks. If there is backpressure
     * this call will block until the invocation is queued. If configureBlocking(false) is invoked
     * then it will return immediately. Check the return value to determine if queueing actually took place.&lt;/p&gt;
     *
     * @param callback {@link ProcedureCallback} that will be invoked with procedure results.
     * @param procedureName class name (not qualified by package) of the procedure to execute.
     * @param params vararg list of procedure's parameter values.
     * @throws NoConnectionsException if this {@link Client} instance is not connected to any servers.
     * @throws IOException if there is a Java network or connection problem.
     */
    public void callProcedureAsync(ProcedureCallback callback, String procedureName, Object... params)
            throws IOException {
<span class="fc" id="L117">        client_.callProcedure(callback, procedureName, params);</span>
<span class="fc" id="L118">    }</span>

    /**
     * Checks for any connection to the VoltDB cluster.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if there is at least one connection; &lt;code&gt;false&lt;/code&gt; if there are no connections.
     */
    public boolean haveConnection() {
<span class="fc bfc" id="L126" title="All 2 branches covered.">        return client_.getConnectedHostList().size() &gt; 0;</span>
    }

    /**
     * Waits for any connection to the VoltDB cluster with a timeout.
     * @param timeoutMilliseconds How many milliseconds to wait for a connection.
     * @return &lt;code&gt;true&lt;/code&gt; if a connection was made within the timeout period or already existed,
     * &lt;code&gt;false&lt;/code&gt; if no connection during timeout period.
     */
    public boolean waitForConnection(long timeoutMilliseconds) {
<span class="fc" id="L136">        long now = Instant.now().toEpochMilli();</span>
<span class="fc" id="L137">        long futureTimeout = now + timeoutMilliseconds;</span>
<span class="fc bfc" id="L138" title="All 4 branches covered.">        while(!haveConnection() &amp;&amp; now &lt; futureTimeout) { // Wait for at least one connection</span>
            try {
<span class="fc" id="L140">                Thread.sleep(100); // Busy wait intentional.</span>
<span class="pc" id="L141">            } catch(InterruptedException e) { /* Ignore this, should not happen */ }</span>
<span class="fc" id="L142">            now = Instant.now().toEpochMilli();</span>
        }
<span class="fc bfc" id="L144" title="All 2 branches covered.">        return now &lt; futureTimeout;</span>
    }

    @Override
    public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {
<span class="fc" id="L149">        connections_.put(hostname, false);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">        if(connectionsLeft == 0)</span>
<span class="fc" id="L151">            log_.severe(&quot;All connections to the VoltDB servers have been lost.&quot;);</span>
        else
<span class="fc" id="L153">            log_.warning(String.format(&quot;Connection to '%s' was disconnected for reason '%s', there are %d &quot; +</span>
<span class="fc" id="L154">                            &quot;connections left.&quot;, hostname, cause.toString(), connectionsLeft));</span>
<span class="fc" id="L155">    }</span>

    @Override
    public void connectionCreated(String hostname, int port, AutoConnectionStatus status) {
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">        if(status == AutoConnectionStatus.SUCCESS &amp;&amp; !connections_.containsKey(hostname))</span>
<span class="fc" id="L160">            connections_.put(hostname, true);</span>
        else
<span class="fc" id="L162">            connections_.put(hostname, false);</span>
<span class="fc" id="L163">    }</span>

    private boolean connectInternal(String server) {
        try {
<span class="fc" id="L167">            client_.createConnection(server, port_);</span>
<span class="fc" id="L168">            return true;</span>
<span class="fc" id="L169">        } catch (IOException e) {</span>
<span class="fc" id="L170">            return false;</span>
        }
    }

    private ClientConfig initClient() {
        ClientConfig config;
<span class="fc" id="L176">        config = new ClientConfig(properties_.getProperty(USERNAME, &quot;&quot;), properties_.getProperty(PASSWORD, &quot;&quot;), this);</span>
<span class="fc" id="L177">        config.enableAutoTune();</span>
<span class="fc" id="L178">        config.setReconnectOnConnectionLoss(true);</span>
<span class="fc" id="L179">        config.setClientAffinity(true);</span>
<span class="fc" id="L180">        config.setTopologyChangeAware(true);</span>
<span class="fc" id="L181">        return config;</span>
    }

    private final Logger              log_;
    private final Properties          properties_;
<span class="fc" id="L186">    private final Map&lt;String,Boolean&gt; connections_ = new ConcurrentHashMap&lt;&gt;();</span>
    private       Client              client_;
    private final int                 port_;
<span class="fc" id="L189">    private       Thread              connectionThread_ = null;</span>

    public static final String USERNAME                  = &quot;username&quot;;
    public static final String PASSWORD                  = &quot;password&quot;;
    public static final String PORT                      = &quot;port&quot;;
    public static final String CONNECTION_RETRY_DELAY_MS = &quot;retry_delay&quot;;
    public static final String SERVERS                   = &quot;list_of_servers&quot;;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>